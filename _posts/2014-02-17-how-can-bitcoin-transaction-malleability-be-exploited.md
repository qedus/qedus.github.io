---
layout: post
title: How can Bitcoin transaction malleability be exploited?
date: '2014-02-17T05:57:00+00:00'
tags:
- bitcoin
---
There has been a lot in the media about the Bitcoin 'bug' that allows [transaction malleability](https://en.bitcoin.it/wiki/Transaction_Malleability) and how several exchanges, mainly Mt Gox, potentially lost bitcoins. I thought I would explain how a poorly designed software could lose money by transaction malleability exploitation. Note that transaction malleability essentially means that an identifier for each transaction could be changed before it is included within a block.

I do not consider the transaction malleability issue to be a bug. Any developer using the bitcoin protocol should understand that everything at the top of the block chain should be considered potential trash. This includes at least the first block and definitely all the unconfirmed transactions. It is the job of all the bitcoin miners to figure out what is and isn't rubbish. There are always going to be bad clients connected to the network that will attempt to exploit this.

So how would poorly designed software that interfaces with the bitcoin network loose money?

If we look at an exchange business we need to make a some assumptions:

* Bitcoin deposits and withdrawals are at least semi-automated.
* Everyone's bitcoins are stored in one giant wallet, not separate wallets for each user.
* The exchange's Bitcoin software assumes that the ID it receives when it makes a transaction on the Bitcoin network is *not* malleable i.e. the ID cannot change.
* The exchange's Bitcoin software has an system to check if transactions have not succeeded and rectify this by resending the transaction.

Here's how the situation would work:

1. A user requests a withdrawal of bitcoins from the exchange.
2. The exchange software initiates a transaction on the Bitcoin network and receives a transaction ID. This transaction is transmitted to all the bitcoin nodes and goes on the pile of unconfirmed transactions.
3. Someone else, a bad actor, sees this unconfirmed transaction and produces an identical one except with a slightly different ID which also goes on the pile of unconfirmed transactions.
4. Now, either the bad actor's transaction or the exchange's transaction will get officially accepted by the Bitcoin network but not both. The other one will be discarded. Note that it does not matter which transaction does get accepted, the user that initiated the withdrawal is still going to get paid.
5. This is the important part. If the bad actor's transaction gets accepted onto the Bitcoin network then we have a problem only for the exchange. Its software, trying to be diligent, will see that the transaction with its ID did not go through, unknowing that the bad actor's transaction went through in its place and actually debited its wallet. There are numerous legitimate reasons why a transaction might not go through so the exchange sends the transaction request again.
6. The user that initiated the withdrawal request now gets double the number of bitcoins he initially requested. One sum from the bad actor's transaction and another from the resent transaction. In both cases the massive exchange wallet is being also debited twice. The worst thing is that this could be done over and over again and accounting error probably would not be noticed until the exchange wallet is practically sucked dry.

What should software that interfaces with the Bitcoin network do instead?

Software should reconcile their potential payments using sent from addresses, sent to addresses and transaction amounts. A transaction match should also only be done on transactions within the blocks with at least a few confirmations. At this point, transaction IDs also become non-malleable incidentally as they are deep within the block chain.